@using System.Collections.Generic
@typeparam TItem
@typeparam TValue
<div class="form-check-list">
    @foreach (var (item, index) in Items.Select((item, index) => (item, index)))
    {
        var value = GetValue(item);
        var checkboxId = $"checkbox_{ComponentId}_{index}";
        <div class="form-check form-check-inline">
            <input class="form-check-input"
                   type="checkbox"
                   id="@checkboxId"
                   checked="@SelectedValues.Contains(value)"
                   onchange="@((ChangeEventArgs e) => HandleCheckboxChange(value, e))" />
            <label class="form-check-label" for="@checkboxId" style="font-size:0.95em">
                @GetDisplayValue(item)
            </label>
        </div>
    }
</div>

@code {
    [Parameter]
    public IReadOnlyList<TItem> Items { get; set; } = new List<TItem>();

    [Parameter]
    public List<TValue> SelectedValues { get; set; } = new List<TValue>();

    [Parameter]
    public EventCallback<List<TValue>> SelectedValuesChanged { get; set; }

    [Parameter]
    public Func<TItem, string> GetDisplayValue { get; set; } = item => item?.ToString() ?? string.Empty;

    [Parameter]
    public Func<TItem, TValue> GetValue { get; set; } = item => (item is TValue value) ? value : default!;

    // Unieke component ID om conflicten te voorkomen
    private readonly string ComponentId = Guid.NewGuid().ToString("N")[..8];

    private async Task HandleCheckboxChange(TValue value, ChangeEventArgs e)
    {
        var isChecked = (bool)(e.Value ?? false);

        if (isChecked)
        {
            if (!SelectedValues.Contains(value))
            {
                SelectedValues.Add(value);
            }
        }
        else
        {
            SelectedValues.Remove(value);
        }

        await SelectedValuesChanged.InvokeAsync(SelectedValues);
    }
}